<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alex&#39;s C++ blog</title>
  
  
  <link href="https://rath3t.github.io/atom.xml" rel="self"/>
  
  <link href="https://rath3t.github.io/"/>
  <updated>2021-06-15T16:16:44.780Z</updated>
  <id>https://rath3t.github.io/</id>
  
  <author>
    <name>Alex MÃ¼ller</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++20 std::ranges</title>
    <link href="https://rath3t.github.io/2021/06/15/ranges/"/>
    <id>https://rath3t.github.io/2021/06/15/ranges/</id>
    <published>2021-06-15T16:16:44.780Z</published>
    <updated>2021-06-15T16:16:44.780Z</updated>
    
    <content type="html"><![CDATA[<p>In my first blog post i will show you my short journey into <code>std::ranges</code>. Ranges were introduced in the C++20 standard and originated from the <a href="https://github.com/ericniebler/range-v3">rangeV3</a> library.<br>In especially, the iteration over collections are super simple now. They also allow to iterate over the results of some member function. This is called projection. I also discuss two example where other capabilities as filtering and views in general are shown</p><h3 id="Example-1-Projection-onto-member-functions"><a href="#Example-1-Projection-onto-member-functions" class="headerlink" title="Example 1: Projection onto member functions"></a>Example 1: Projection onto member functions</h3><p>Consider the following struct which has three member functions:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">/*calc area */</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">/*calc volume */</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std:<span class="function">pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; <span class="title">getVolumeAndArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::make_pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;(<span class="built_in">getVolume</span>(), <span class="built_in">getArea</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* some data members */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we have a vector of shapes and want to iterate over the vector but we want as quantity directly the return value of the member function, i.e. we have</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">std:vector&lt;Shape&gt; shapes;</span><br><span class="line"><span class="comment">/* fill shapes */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> area : <span class="built_in">area</span>(shapes))</span><br><span class="line">  <span class="comment">/* do something with area */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> volume : <span class="built_in">volume</span>(shapes))</span><br><span class="line">  <span class="comment">/* do something with volume */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> [volume, area] : <span class="built_in">volumeAndArea</span>(shapes))</span><br><span class="line">  <span class="comment">/* do something with volume and area */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This behavior can be accomplished with so called <code>views</code> in <a href="https://en.cppreference.com/w/cpp/ranges"><code>std::ranges</code></a>. We need for this task <a href="https://en.cppreference.com/w/cpp/ranges/transform_view"><code>std::ranges::views::transform</code></a> or the synonym <a href="https://en.cppreference.com/w/cpp/ranges/transform_view"><code>std::ranges::transform_view</code></a> to which we can directly pass a pointer to a member function.</p><p>We can then write</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> area : std::ranges::<span class="built_in">transform_view</span>(shapes, &amp;Shape::getArea ))</span><br><span class="line">        std::cout &lt;&lt; area &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>which can also be wrapped obviously into a function</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">area</span><span class="params">(std::vector&lt;Shape&gt;&amp; shapes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::ranges::transform_view;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">transform_view</span>(shapes, &amp;Shape::getArea);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://godbolt.org/z/EsKzz3v8x">godbolt.org</a></p><p><code>transform_view</code> is also suited for a more general approach. We can plugin anything invokable, e.g. lambdas as follows</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">auto</span> lambda = [&amp;i](<span class="keyword">auto</span>&amp; shape)&#123;<span class="keyword">return</span> i++*shape.<span class="built_in">getArea</span>(); &#125;;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> areaMultiples :  std::ranges::<span class="built_in">transform_view</span>(shapes, lambda ))</span><br><span class="line">       std::cout &lt;&lt; areaMultiples &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://godbolt.org/z/Y146xKfMs">godbolt.org</a></p><p>I think this approach pretty nice since it reduces a lot of noise around how to iterate over collections.</p><p>Using the lambda we can also call member functions which need arguments.<br>If we have the member function as follows</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>*i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>We can also use it in the following way</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [&amp;i](<span class="keyword">auto</span>&amp; shape)&#123;<span class="keyword">return</span> shape.<span class="built_in">getArea</span>(i++); &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> areaMultiples :  <span class="built_in">transform_view</span>(shapes, lambda ))</span><br><span class="line">    std::cout &lt;&lt; areaMultiples &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><a href="https://godbolt.org/z/3hKcjar4s">godbolt.org</a></p><h3 id="Example-2-Iterate-over-a-filtered-subset-of-a-collection"><a href="#Example-2-Iterate-over-a-filtered-subset-of-a-collection" class="headerlink" title="Example 2: Iterate over a filtered subset of a collection"></a>Example 2: Iterate over a filtered subset of a collection</h3><p>Another nice example is the feature to filter automatically the stuff which you are not interested in.<br>This can be done with <a href="https://en.cppreference.com/w/cpp/ranges/filter_view"><code> std::ranges::filter_view</code></a> or again with the synonym <a href="https://en.cppreference.com/w/cpp/ranges/filter_view"><code>std::ranges::views::filter</code></a>.</p><p>We have a vector of integers. We only want to iterate over the prime numbers. This can be done in the following old school way:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= std::<span class="built_in">sqrt</span>(n); i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i : v)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPrime</span>(i)) <span class="comment">/* byhand label in the figure */</span></span><br><span class="line">          <span class="comment">/* do something with the primes */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Using the ranges library we can write</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i :  std::ranges::<span class="built_in">filter_view</span>(v,isPrime)) <span class="comment">/* ranges2 label in the figure */</span></span><br><span class="line">          <span class="comment">/* do something with the primes */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or equivalently</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i : v | std::views::<span class="built_in">filter</span>(isPrime)) <span class="comment">/* ranges1 label in the figure */</span></span><br><span class="line">          <span class="comment">/* do something with the primes */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>where the operator <code>|</code> unites the predicate <code>isPrime</code> with the vector <code>v</code>.<br>I also benchmarked all three examples at <a href="https://www.quick-bench.com/q/hC-zMSq9EkG4dgZjTCKLUUdAa90">quickbench</a> using a vector with 1000 entries, see Figure below.<br><img title="a title" alt="Alt text" src="/source/_posts/images/rangesEqualSpeed.png"><br>As you can see, there is almost no difference in the time taken. At least for the gcc10.2 compiler.</p><p>Nevertheless, if we change the predicate <code>isPrime</code> to something trivial, e.g.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br></pre></td></tr></table></figure><p>The benchmark result changes to <a href="https://www.quick-bench.com/q/aOGmAl94qbjJZfsinXrqOlxjDyk#">quickbench</a>.<br><img title="a title" alt="Alt text" src="/images/_posts/rangesDifferentSpeed.png"><br><img src="/rangesDifferentSpeed.png"><br>Here, one can see that the by hand approach is much faster. In my opinion this is due to the inlining of the function in the <code>byHand</code> approach.</p><p>Intrestingly,<br>if i change the predicate slightly by introducing the function to be <code>constexpr</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The results are again quite different and the <code>ranges1</code> approach gains speed:<br><img title="a title" alt="Alt text" src="/images/rangesDifferentWithConstexprSpeed.png"></p><h3 id="Example-3-Iterate-over-a-view-without-storing-any-collection-directly"><a href="#Example-3-Iterate-over-a-view-without-storing-any-collection-directly" class="headerlink" title="Example 3: Iterate over a view without storing any collection directly"></a>Example 3: Iterate over a view without storing any collection directly</h3><p>In the example before i always wrote <code>std::vector&lt;int&gt; v&#123;0,1,2,3,4,5&#125;;</code> to define a vector over which we iterated. As you may have noticed, i used a different approach in the benchmark examples. With the ranges library you can construct views directly and never even have to store the complete vector. E.g. we can use <code>std::ranges::iota_view</code> as follows</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> v = std::ranges::iota_view&#123;<span class="number">1</span>, <span class="number">1000</span>&#125;;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">  <span class="comment">/* do something with i */</span></span><br></pre></td></tr></table></figure><p>or directly</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : std::ranges::iota_view&#123;<span class="number">1</span>, <span class="number">1000</span>&#125;)</span><br><span class="line">  <span class="comment">/* do something with i */</span></span><br></pre></td></tr></table></figure><h3 id="Bonus-Chaining-stuff-together"><a href="#Bonus-Chaining-stuff-together" class="headerlink" title="Bonus: Chaining stuff together"></a>Bonus: Chaining stuff together</h3><p>You can also chain operation together, e.g. if we want to iterate over the square of primes:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">   <span class="keyword">auto</span> square = [](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i * i; &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i : v | std::views::<span class="built_in">filter</span>(isPrime) | std::views::<span class="built_in">transform</span>(square))</span><br><span class="line">          <span class="comment">/* do something with the squares of primes */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>At least to me these views seem to be really powerful.</p><!---#include <ranges>#include <vector>bool isPrime(int n){    return true;}static void ranges1(benchmark::State& state) {   auto v = std::ranges::iota_view{1, 1000};   int sumOverPrimes = 0;  for (auto _ : state) {    for(int i : v | std::views::filter(isPrime))       benchmark::DoNotOptimize(i);  }}// Register the function as a benchmarkBENCHMARK(ranges1);static void ranges2(benchmark::State& state) {   auto v = std::ranges::iota_view{1, 1000};   int sumOverPrimes = 0;  for (auto _ : state) {    for(int i :  std::ranges::filter_view(v,isPrime))       benchmark::DoNotOptimize(i);  }}// Register the function as a benchmarkBENCHMARK(ranges2);static void byhand(benchmark::State& state) {  auto v = std::ranges::iota_view{1, 1000};  int sumOverPrimes = 0;  for (auto _ : state) {    for(int i : v)      if (isPrime(i))          benchmark::DoNotOptimize(i);  }}BENCHMARK(byhand);-->]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;In my first blog post i will show you my short journey into &lt;code&gt;std::ranges&lt;/code&gt;. Ranges were introduced in the C++20 standard and or</summary>
      
    
    
    
    
  </entry>
  
</feed>
